import express from 'express';
import ChatBotService from '../services/ChatBotService.js';

const router = express.Router();
const chatBotService = new ChatBotService();

// Store conversation history (trong production n√™n d√πng Redis/Database)
const conversationStore = new Map();

// ‚úÖ CORS MIDDLEWARE PH·∫¢I ·ªû ƒê·∫¶U FILE
router.use((req, res, next) => {
    // Log incoming requests
    console.log(`üì• [${new Date().toISOString()}] ${req.method} ${req.path}`, {
        body: req.body ? Object.keys(req.body) : 'no body',
        headers: {
            'content-type': req.headers['content-type'],
                'origin': req.headers['origin']
        }
    });

    // Set CORS headers
    res.header('Access-Control-Allow-Origin', '*');
    res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
    res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization, Cache-Control, Pragma');
    
    // Handle preflight requests
    if (req.method === 'OPTIONS') {
        console.log('‚úÖ Handling OPTIONS preflight request');
        res.sendStatus(200);
        return;
    }
    
    next();
});

// ‚úÖ HEALTH CHECK ENDPOINT
router.get('/health', (req, res) => {
    res.json({
        success: true,
        message: 'ChatBot API is running',
        timestamp: new Date().toISOString(),
        endpoints: {
            chat: '/api/chatbot/chat',
            prompt: '/api/chatbot/prompt',
            modelInfo: '/api/chatbot/model-info',
            health: '/api/chatbot/health'
        }
    });
});

// ‚úÖ TEST DATABASE CONNECTION
router.get('/test-db', async (req, res) => {
    try {
        const dbTests = await chatBotService.dbContext.testDatabaseConnection();
        res.json({
            success: true,
            message: 'Database connection test completed',
            results: dbTests,
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: 'Database connection test failed',
            error: error.message,
            timestamp: new Date().toISOString()
        });
    }
});

// ‚úÖ CACHE STATUS ENDPOINT
router.get('/cache-status', (req, res) => {
    const cacheStatus = chatBotService.getCacheStatus();
    res.json({
        success: true,
        cache: cacheStatus,
        timestamp: new Date().toISOString()
    });
});

// ‚úÖ REFRESH CACHE ENDPOINT
router.post('/refresh-cache', async (req, res) => {
    try {
        const data = await chatBotService.refreshCache();
        res.json({
            success: true,
            message: 'Cache refreshed successfully',
            data: {
                roomTypes: data.roomTypes?.length || 0,
                availableRooms: data.availableRooms?.length || 0,
                promotions: data.promotions?.length || 0,
                services: data.services?.length || 0
            },
            timestamp: new Date().toISOString()
        });
    } catch (error) {
        res.status(500).json({
            success: false,
            message: 'Failed to refresh cache',
            error: error.message,
            timestamp: new Date().toISOString()
        });
    }
});

// ‚úÖ PROMPT ENDPOINT - MUST BE POST
router.post('/prompt', async (req, res) => {
    try {
        console.log('üì® Prompt endpoint hit:', {
            method: req.method,
            body: req.body,
            headers: {
                'content-type': req.headers['content-type']
            }
        });

        const { prompt, sessionId } = req.body;

        if (!prompt || prompt.trim() === '') {
            console.log('‚ùå Invalid prompt:', prompt);
            return res.status(400).json({
                success: false,
                error: 'Prompt is required'
            });
        }

        // Validate prompt length
        if (prompt.length > 2000) {
            return res.status(400).json({
                success: false,
                error: 'Prompt too long. Maximum 2000 characters.',
                response: 'Prompt qu√° d√†i. Vui l√≤ng vi·∫øt ng·∫Øn g·ªçn h∆°n (t·ªëi ƒëa 2000 k√Ω t·ª±).'
            });
        }

        // T·∫°o session ID n·∫øu kh√¥ng c√≥
        const userSessionId = sessionId || `prompt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

        // L·∫•y l·ªãch s·ª≠ h·ªôi tho·∫°i
        let conversationHistory = conversationStore.get(userSessionId) || [];

        console.log(`[Direct Prompt] Session: ${userSessionId}, Prompt: ${prompt.substring(0, 100)}...`);

        // G·ªçi AI ƒë·ªÉ x·ª≠ l√Ω prompt tr·ª±c ti·∫øp
        const aiResponse = await chatBotService.handleDirectPrompt(prompt, conversationHistory);

        // C·∫≠p nh·∫≠t l·ªãch s·ª≠ h·ªôi tho·∫°i
        conversationHistory.push(
            { role: 'user', content: prompt, timestamp: new Date().toISOString(), type: 'prompt' },
            { role: 'assistant', content: aiResponse.response, timestamp: aiResponse.timestamp, type: 'prompt_response' }
        );

        // Gi·ªõi h·∫°n l·ªãch s·ª≠
        if (conversationHistory.length > 20) {
            conversationHistory = conversationHistory.slice(-20);
        }

        // L∆∞u l·∫°i l·ªãch s·ª≠
        conversationStore.set(userSessionId, conversationHistory);

        // Session cleanup
        setTimeout(() => {
            if (conversationStore.has(userSessionId)) {
                console.log(`[Direct Prompt] Cleaned up session: ${userSessionId}`);
                conversationStore.delete(userSessionId);
            }
        }, 2 * 60 * 60 * 1000); // 2 hours for prompts

        // T·∫°o quick replies cho prompt
        const quickReplies = chatBotService.getQuickReplies('direct_prompt');

        res.json({
            success: aiResponse.success,
            response: aiResponse.response,
            sessionId: userSessionId,
            intent: 'direct_prompt',
            quickReplies: quickReplies,
            timestamp: aiResponse.timestamp,
            model: aiResponse.model || 'gemini-1.5-flash',
            promptType: aiResponse.promptType || 'direct',
            originalPrompt: prompt.substring(0, 100) + (prompt.length > 100 ? '...' : ''),
            conversationLength: conversationHistory.length
        });

    } catch (error) {
        console.error('‚ùå Direct Prompt API Error:', error);
        
        const errorResponse = {
            success: false,
            error: 'Internal server error',
            response: 'Xin l·ªói, t√¥i kh√¥ng th·ªÉ x·ª≠ l√Ω prompt n√†y l√∫c n√†y. Vui l√≤ng th·ª≠ l·∫°i sau.',
            model: 'gemini-1.5-flash-error',
            timestamp: new Date().toISOString(),
            promptType: 'direct'
        };

        res.status(500).json(errorResponse);
    }
});

// ‚úÖ ENHANCED ROLE-BASED CONTEXT
router.post('/chat', async (req, res) => {
    try {
        const { 
            message, 
            sessionId = `session_${Date.now()}`,
            userRole = 'customer',
            userId = null,
            context = {}
        } = req.body;

        console.log('üí¨ Enhanced Chat request:', {
            message: message?.substring(0, 50) + '...',
            userRole,
            userId,
            hasContext: Object.keys(context).length > 0,
            contextKeys: Object.keys(context)
        });

        if (!message || message.trim() === '') {
            return res.status(400).json({
                success: false,
                error: 'Message cannot be empty'
            });
        }

        // ‚úÖ ENHANCED ROLE-BASED CONTEXT WITH REAL DATA
        let enhancedContext = '';
        
        switch (userRole) {
            case 'manager':
                enhancedContext = `
                B·∫°n ƒëang h·ªó tr·ª£ MANAGER c·ªßa Hotel HUB. Cung c·∫•p th√¥ng tin executive-level:
                - Strategic insights v√† business analytics
                - Revenue optimization v√† market analysis  
                - Staff performance v√† operational efficiency
                - Long-term planning v√† growth strategies
                - Competitive analysis v√† industry trends
                - Executive summary format v·ªõi key metrics
                - Decision support v·ªõi data-driven recommendations
                Tone: Professional, strategic, data-focused
                Response format: Tr·∫£ l·ªùi CH√çNH X√ÅC b·∫±ng text string, kh√¥ng format JSON
                `;
                break;
                
            case 'receptionist':
                enhancedContext = `
                B·∫°n ƒëang h·ªó tr·ª£ L·ªÑT√ÇN c·ªßa Hotel HUB v·ªõi full access to real-time data. ∆Øu ti√™n:
                - Real-time room status v√† booking management (120 ph√≤ng available)
                - Check-in/check-out procedures v√† guest handling
                - Payment processing v√† billing operations
                - Guest services v√† special requests handling
                - Housekeeping coordination v√† maintenance scheduling
                - Complaint resolution v√† customer satisfaction
                - Daily operations reporting v√† shift handover
                - VIP guest management v√† protocol
                - Emergency procedures v√† security protocols
                
                Current Hotel Data Available:
                ‚Ä¢ 120 ph√≤ng v·ªõi real-time status tracking
                ‚Ä¢ 6 lo·∫°i ph√≤ng v·ªõi pricing tiers kh√°c nhau
                ‚Ä¢ 5 d·ªãch v·ª• premium available
                ‚Ä¢ 2 khuy·∫øn m√£i hi·ªán t·∫°i ƒëang active
                ‚Ä¢ Payment systems: VNPay, MoMo, QR Banking
                ‚Ä¢ Hotline: 0865.124.996 (24/7 support)
                
                Tone: Professional, helpful, solution-oriented, detailed
                Response style: Provide actionable information v·ªõi step-by-step guidance
                Response format: Tr·∫£ l·ªùi CH√çNH X√ÅC b·∫±ng text string, kh√¥ng format JSON
                `;
                break;
                
            case 'customer':
            default:
                enhancedContext = `
                B·∫°n ƒëang h·ªó tr·ª£ KH√ÅCH H√ÄNG c·ªßa Hotel HUB. T·∫≠p trung:
                - Th√¥ng tin ƒë·∫∑t ph√≤ng v√† room availability
                - Gi√° c·∫£, promotions, v√† booking packages  
                - Hotel amenities v√† premium services
                - Local attractions v√† travel recommendations
                - Friendly, welcoming tone v·ªõi sales opportunities
                - Guest satisfaction v√† memorable experience
                - Upselling c∆° h·ªôi v·ªõi c√°c d·ªãch v·ª• premium
                
                Current Offers:
                ‚Ä¢ 120 ph√≤ng available v·ªõi 6 room types
                ‚Ä¢ Promotions active: Student discount, Birthday special
                ‚Ä¢ Services: Spa, Restaurant, Airport transfer
                ‚Ä¢ Location: FPT University area, H√≤a L·∫°c, H√† N·ªôi
                
                Tone: Warm, welcoming, sales-oriented
                Response format: Tr·∫£ l·ªùi CH√çNH X√ÅC b·∫±ng text string, kh√¥ng format JSON ho·∫∑c object
                `;
                break;
        }

        // ‚úÖ BUILD ROLE-BASED PROMPT WITH ENHANCED CONTEXT
        const roleBasedPrompt = `${enhancedContext}\n\nIMPORTANT: Ch·ªâ tr·∫£ l·ªùi b·∫±ng TEXT THU·∫¶N T√öY, kh√¥ng d√πng JSON format, kh√¥ng d√πng object.\n\nUser (${userRole}): ${message}`;

        // Generate response with enhanced role context
        const response = await chatBotService.generateResponse(
            roleBasedPrompt, 
            [] // conversation history can be added later
        );

        // ‚úÖ ENHANCED ROLE-BASED QUICK REPLIES
        const quickReplies = getEnhancedRoleQuickReplies(userRole, message);

        // ‚úÖ STRICT RESPONSE TYPE VALIDATION
        let finalResponse;
        if (typeof response === 'string') {
            finalResponse = response;
        } else if (response && typeof response === 'object') {
            // Extract text from object response
            if (response.text) {
                finalResponse = response.text;
            } else if (response.message) {
                finalResponse = response.message;
            } else if (response.response) {
                finalResponse = response.response;
            } else {
                finalResponse = JSON.stringify(response);
            }
        } else {
            finalResponse = String(response || 'Kh√¥ng th·ªÉ t·∫°o ph·∫£n h·ªìi');
        }

        // Validate final response
        if (!finalResponse || finalResponse.trim() === '') {
            finalResponse = `Xin l·ªói, t√¥i kh√¥ng th·ªÉ tr·∫£ l·ªùi c√¢u h·ªèi "${message}" l√∫c n√†y. Vui l√≤ng th·ª≠ h·ªèi theo c√°ch kh√°c ho·∫∑c li√™n h·ªá hotline 0865.124.996 ƒë·ªÉ ƒë∆∞·ª£c h·ªó tr·ª£ tr·ª±c ti·∫øp.`;
        }

        console.log('‚úÖ Final response validation:', {
            originalType: typeof response,
            finalType: typeof finalResponse,
            length: finalResponse.length,
            preview: finalResponse.substring(0, 100) + '...'
        });

        res.json({
            success: true,
            response: finalResponse, // ‚úÖ GUARANTEED STRING
            quickReplies: quickReplies,
            sessionId: sessionId,
            userRole: userRole,
            timestamp: new Date().toISOString(),
            model: 'gemini-1.5-flash',
            dataStatus: {
                roomsAvailable: 120,
                roomTypes: 6,
                activePromotions: 2,
                servicesOffered: 5
            }
        });

    } catch (error) {
        console.error('‚ùå Enhanced Chat endpoint error:', error);
        res.status(500).json({
            success: false,
            error: 'Internal server error',
            response: 'H·ªá th·ªëng chatbot t·∫°m th·ªùi g·∫∑p s·ª± c·ªë. Vui l√≤ng th·ª≠ l·∫°i sau ho·∫∑c li√™n h·ªá hotline 0865.124.996.',
            fallbackActions: {
                receptionist: ['Use dashboard at /receptionist', 'Call IT: 0865.124.996'],
                customer: ['Browse rooms manually', 'Call hotline: 0865.124.996'],
                manager: ['Check analytics dashboard', 'Contact IT support']
            }
        });
    }
});

// ‚úÖ ENHANCED HELPER FUNCTION FOR ROLE-BASED QUICK REPLIES
function getEnhancedRoleQuickReplies(userRole, message) {
    const lowerMessage = message.toLowerCase();
    
    switch (userRole) {
        case 'manager':
            if (lowerMessage.includes('b√°o c√°o') || lowerMessage.includes('report')) {
                return ['üìä Executive Dashboard', 'üí∞ Revenue Analysis', 'üë• Staff Performance', 'üìà Market Trends'];
            }
            if (lowerMessage.includes('doanh thu') || lowerMessage.includes('revenue')) {
                return ['üí∞ Today Revenue', 'üìà Monthly Trends', 'üèÜ Best Performers', 'üí° Optimization Tips'];
            }
            return ['üìä Analytics', 'üí∞ Revenue', 'üë• Staff', 'üìà Growth Strategy'];
            
        case 'receptionist':
            if (lowerMessage.includes('ph√≤ng') || lowerMessage.includes('room')) {
                return ['üè® 120 Ph√≤ng Status', 'üßπ Housekeeping', 'üîß Maintenance', 'üìã Reservations'];
            } else if (lowerMessage.includes('kh√°ch') || lowerMessage.includes('guest')) {
                return ['‚úÖ Check-in Today', 'üö™ Check-out List', 'üõéÔ∏è VIP Requests', 'üìû Guest Issues'];
            } else if (lowerMessage.includes('thanh to√°n') || lowerMessage.includes('payment')) {
                return ['üí≥ Payment Process', 'üßæ Print Receipt', 'üí∞ Reconcile Shift', 'üìä Payment Stats'];
            } else if (lowerMessage.includes('th·ªùi ti·∫øt') || lowerMessage.includes('weather')) {
                return ['üå§Ô∏è HN Weather Today', 'üìÖ Weekly Forecast', 'üß≥ Guest Recommendations', 'üåßÔ∏è Weather Alerts'];
            }
            return ['üè® Room Status', 'üìã Bookings', 'üë• Guests', 'üí≥ Payments', 'üìä Reports'];
            
        case 'customer':
        default:
            if (lowerMessage.includes('ph√≤ng') || lowerMessage.includes('room')) {
                return ['üõèÔ∏è Room Types', 'üí∞ Best Prices', 'üìÖ Availability', 'üéÅ Special Offers'];
            } else if (lowerMessage.includes('th·ªùi ti·∫øt') || lowerMessage.includes('weather')) {
                return ['üå§Ô∏è HN Weather', 'üß≥ What to Pack', 'üìÖ Best Season', 'üåßÔ∏è Rain Forecast'];
            }
            return ['üõèÔ∏è Book Room', 'üåü Services', 'üéÅ Promotions', 'üìç Location', 'üå§Ô∏è Weather'];
    }
}

// ‚úÖ MODEL INFO ENDPOINT
router.get('/model-info', (req, res) => {
    res.json({
        success: true,
        model: {
            name: 'Gemini 1.5 Flash',
            version: '1.5',
            provider: 'Google AI',
            capabilities: ['text-generation', 'conversation', 'prompt-processing'],
            maxTokens: 8192,
            temperature: 0.7
        },
        features: [
            'Hotel booking assistance',
            'Room information',
            'Local attractions guide',
            'Weather information',
            'Travel recommendations'
        ],
        timestamp: new Date().toISOString()
    });
});

// ‚úÖ PROMPT EXAMPLES ENDPOINT
router.get('/prompt-examples', (req, res) => {
    res.json({
        success: true,
        examples: [
            "Vi·∫øt email ch√†o m·ª´ng kh√°ch h√†ng ƒë·∫øn Hotel HUB",
            "T·∫°o m√¥ t·∫£ chi ti·∫øt v·ªÅ ph√≤ng Suite cao c·∫•p",
            "H∆∞·ªõng d·∫´n chu·∫©n b·ªã ƒë·ªì d√πng theo th·ªùi ti·∫øt H√† N·ªôi",
            "L·∫≠p k·∫ø ho·∫°ch tham quan H√† N·ªôi 3 ng√†y 2 ƒë√™m",
            "So s√°nh c√°c lo·∫°i ph√≤ng v√† d·ªãch v·ª• c·ªßa hotel",
            "Ph√¢n t√≠ch th·ªùi ti·∫øt theo m√πa ·ªü khu v·ª±c H√≤a L·∫°c"
        ],
        categories: [
            "Hotel & Accommodation",
            "Weather & Climate", 
            "Travel Planning",
            "Local Attractions",
            "Food & Culture"
        ],
        timestamp: new Date().toISOString()
    });
});

// ‚úÖ WEATHER INFO ENDPOINT
router.get('/weather-info', (req, res) => {
    res.json({
        success: true,
        location: "H√† N·ªôi, Vi·ªát Nam",
        seasons: {
            spring: { months: "Feb-Apr", temp: "18-25¬∞C", description: "M√°t m·∫ª, √≠t m∆∞a" },
            summer: { months: "May-Aug", temp: "25-35¬∞C", description: "N√≥ng ·∫©m, m∆∞a nhi·ªÅu" },
            autumn: { months: "Sep-Nov", temp: "20-28¬∞C", description: "M√°t m·∫ª, ƒë·∫πp nh·∫•t nƒÉm" },
            winter: { months: "Dec-Jan", temp: "10-20¬∞C", description: "L·∫°nh, kh√¥ r√°o" }
        },
        currentSeason: getCurrentSeason(),
        timestamp: new Date().toISOString()
    });
});

// ‚úÖ LOCAL ATTRACTIONS ENDPOINT
router.get('/local-attractions', (req, res) => {
    res.json({
        success: true,
        nearHotel: [
            { name: "Ch√πa H∆∞∆°ng", distance: "15km", time: "30 ph√∫t", type: "T√¢m linh" },
            { name: "Ba V√¨ National Park", distance: "40km", time: "1 gi·ªù", type: "Thi√™n nhi√™n" },
            { name: "ƒê·∫ßm V·∫°c - V√¢n H√≤a", distance: "20km", time: "40 ph√∫t", type: "Sinh th√°i" }
        ],
        inHanoi: [
            { name: "Ph·ªë C·ªï H√† N·ªôi", distance: "45km", time: "1 gi·ªù", type: "VƒÉn h√≥a" },
            { name: "H·ªì G∆∞∆°m", distance: "45km", time: "1 gi·ªù", type: "Danh lam" },
            { name: "VƒÉn Mi·∫øu", distance: "40km", time: "50 ph√∫t", type: "L·ªãch s·ª≠" }
        ],
        timestamp: new Date().toISOString()
    });
});

// Helper function
function getCurrentSeason() {
    const month = new Date().getMonth() + 1;
    if (month >= 2 && month <= 4) return 'spring';
    if (month >= 5 && month <= 8) return 'summer';
    if (month >= 9 && month <= 11) return 'autumn';
    return 'winter';
}

// ‚úÖ EXPORT ROUTER
export default router;