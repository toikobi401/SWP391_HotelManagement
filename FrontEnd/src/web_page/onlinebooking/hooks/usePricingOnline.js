import { useState, useEffect, useCallback } from 'react';

export const usePricingOnline = (formData, selectedRooms, selectedServices, availableServices, appliedPromotion = null, roomTypes = []) => {
  const [pricingBreakdown, setPricingBreakdown] = useState({
    roomSubtotal: 0,
    servicesSubtotal: 0,
    subtotal: 0,
    nightCount: 0,
    lateCheckoutFee: 0,
    totalPrice: 0,
    originalTotal: 0,
    promotionDiscount: 0,
    finalTotal: 0,
    appliedPromotionInfo: null,
    roomsBreakdown: []
  });

  // ‚úÖ TH√äM roomTypes v√†o dependency array
  useEffect(() => {
    // ‚úÖ Safety checks tr∆∞·ªõc khi calculate
    if (!formData) {
      console.warn('FormData is undefined in usePricingOnline');
      return;
    }

    if (!Array.isArray(selectedRooms)) {
      console.warn('SelectedRooms is not an array in usePricingOnline');
      return;
    }

    if (!Array.isArray(roomTypes)) {
      console.warn('RoomTypes is not an array in usePricingOnline');
      return;
    }

    if (formData.checkIn && formData.checkOut && selectedRooms.length > 0 && roomTypes.length > 0) {
      calculatePricing();
    } else {
      // ‚úÖ Reset pricing khi kh√¥ng c√≥ data
      setPricingBreakdown(prev => ({
        ...prev,
        roomSubtotal: 0,
        servicesSubtotal: 0,
        subtotal: 0,
        nightCount: 0,
        lateCheckoutFee: 0,
        totalPrice: 0,
        originalTotal: 0,
        promotionDiscount: 0,
        finalTotal: 0,
        roomsBreakdown: []
      }));
    }
  }, [
    formData?.checkIn, 
    formData?.checkOut, 
    selectedRooms, 
    selectedServices, 
    appliedPromotion, 
    availableServices,
    roomTypes // ‚úÖ TH√äM roomTypes v√†o dependency array
  ]);

  // ‚úÖ T√≠nh s·ªë ƒë√™m
  const calculateNights = useCallback((checkIn, checkOut) => {
    if (!checkIn || !checkOut) return 0;
    
    try {
      const checkInDate = new Date(checkIn);
      const checkOutDate = new Date(checkOut);
      
      if (isNaN(checkInDate.getTime()) || isNaN(checkOutDate.getTime())) {
        console.error('Invalid dates in calculateNights:', { checkIn, checkOut });
        return 0;
      }
      
      const timeDifference = checkOutDate.getTime() - checkInDate.getTime();
      return Math.max(1, Math.ceil(timeDifference / (1000 * 3600 * 24)));
    } catch (error) {
      console.error('Error calculating nights:', error);
      return 1; // Default to 1 night
    }
  }, []);

  // ‚úÖ S·ª¨A: T√≠nh ph√≠ checkout mu·ªôn v·ªõi room types data
  const calculateLateCheckoutFee = useCallback((checkOut, roomsData, roomTypesData) => {
    if (!checkOut || !roomsData || !Array.isArray(roomsData) || !Array.isArray(roomTypesData)) return 0;
    
    try {
      const checkOutDate = new Date(checkOut);
      if (isNaN(checkOutDate.getTime())) return 0;
      
      const checkOutHour = checkOutDate.getHours();
      const checkOutMinute = checkOutDate.getMinutes();
      const checkOutTime = checkOutHour + (checkOutMinute / 60);
      
      // ‚úÖ CH·ªà t√≠nh ph√≠ khi SAU 11:30 (> 11.5 hours)
      if (checkOutTime <= 11.5) return 0;
      
      // ‚úÖ T√≠nh s·ªë gi·ªù v∆∞·ª£t qu√° 11:30
      const hoursOverdue = Math.ceil(checkOutTime - 11.5);
      
      // ‚úÖ S·ª¨A: T√≠nh ph√≠ d·ª±a tr√™n gi√° ph√≤ng th·ª±c t·∫ø t·ª´ roomTypes
      let totalLateFee = 0;
      
      roomsData.forEach(room => {
        // ‚úÖ T√¨m room type t·ª´ roomTypesData
        const roomType = roomTypesData.find(rt => rt.id === String(room.roomTypeId));
        if (roomType) {
          const roomPrice = parseFloat(roomType.price) || 0;
          const roomQuantity = parseInt(room.quantity) || 0;
          const lateFeePer10Percent = roomPrice * 0.1; // 10% gi√° ph√≤ng
          const roomLateFee = lateFeePer10Percent * hoursOverdue * roomQuantity;
          totalLateFee += roomLateFee;
          
          console.log(`üè® Late fee for ${roomType.name}: ${roomPrice.toLocaleString()}ƒë √ó 10% √ó ${hoursOverdue}h √ó ${roomQuantity} = ${roomLateFee.toLocaleString()}ƒë`);
        } else {
          console.warn(`‚ö†Ô∏è Room type not found for ID: ${room.roomTypeId}`);
        }
      });
      
      console.log('üí∞ Total late checkout fee calculation:', {
        checkOutTime: `${checkOutHour}:${checkOutMinute.toString().padStart(2, '0')}`,
        checkOutTimeDecimal: checkOutTime,
        isLate: checkOutTime > 11.5,
        hoursOverdue,
        totalLateFee: totalLateFee.toLocaleString(),
        formula: '(10% √ó gi√° ph√≤ng/ƒë√™m) √ó s·ªë gi·ªù tr·ªÖ √ó s·ªë ph√≤ng'
      });
      
      return totalLateFee;
    } catch (error) {
      console.error('Error calculating late checkout fee:', error);
      return 0;
    }
  }, []);

  // ‚úÖ T√≠nh services total t·ª´ database (gi·ªØ nguy√™n)
  const calculateServiceTotal = useCallback((selectedServiceIds, servicesFromDB) => {
    if (!Array.isArray(selectedServiceIds) || !Array.isArray(servicesFromDB)) {
      console.warn('Invalid data for service calculation:', { selectedServiceIds, servicesFromDB });
      return 0;
    }

    const total = selectedServiceIds.reduce((total, serviceId) => {
      // ‚úÖ T√¨m service t·ª´ database tr∆∞·ªõc
      const serviceFromDB = servicesFromDB.find(service => service.id === serviceId);
      
      if (serviceFromDB) {
        console.log(`üõéÔ∏è Service from DB: ${serviceFromDB.name} - ${serviceFromDB.price.toLocaleString()}ƒë`);
        return total + (serviceFromDB.price || 0);
      }
      
      // ‚úÖ Fallback n·∫øu kh√¥ng t√¨m th·∫•y trong DB
      console.warn(`‚ö†Ô∏è Service ID ${serviceId} not found in database, using fallback`);
      return total + 0;
    }, 0);

    console.log('üí∞ Services total from database:', {
      selectedServices: selectedServiceIds.length,
      totalAmount: total.toLocaleString() + 'ƒë',
      servicesFromDB: servicesFromDB.length
    });

    return total;
  }, []);

  // ‚úÖ Calculate promotion discount (gi·ªØ nguy√™n)
  const calculatePromotionDiscount = useCallback((subtotal, promotion) => {
    if (!promotion || !subtotal || subtotal <= 0) {
      return 0;
    }
    
    const discountAmount = (subtotal * (promotion.discountPercent || 0)) / 100;
    return Math.round(discountAmount);
  }, []);

  // ‚úÖ S·ª¨A: Main pricing calculation function v·ªõi room types
  const calculatePricing = useCallback(() => {
    try {
      console.log('üßÆ Starting pricing calculation for online booking...');
      
      // ‚úÖ Safety checks
      if (!formData || !Array.isArray(selectedRooms) || !Array.isArray(roomTypes)) {
        console.warn('Missing required data for pricing calculation');
        return;
      }

      // Calculate room subtotal and breakdown
      let roomSubtotal = 0;
      const roomsBreakdown = [];
      const nightCount = calculateNights(formData.checkIn, formData.checkOut);
      
      // ‚úÖ ƒê·∫£m b·∫£o lu√¥n c√≥ nightCount, n·∫øu kh√¥ng c√≥ th√¨ s·ª≠ d·ª•ng 1
      const effectiveNightCount = Math.max(1, nightCount);
      
      if (selectedRooms.length > 0) {
        selectedRooms.forEach(room => {
          // ‚úÖ S·ª¨A: T√¨m room type t·ª´ roomTypes data
          const roomType = roomTypes.find(rt => rt.id === String(room.roomTypeId));
          
          if (roomType) {
            const roomPrice = parseFloat(roomType.price) || 0;
            const roomQuantity = parseInt(room.quantity) || 0;
            const roomTotal = roomPrice * roomQuantity * effectiveNightCount;
            
            roomSubtotal += roomTotal;
            
            roomsBreakdown.push({
              roomTypeId: room.roomTypeId,
              name: roomType.name,
              price: roomPrice,
              quantity: roomQuantity,
              nights: effectiveNightCount,
              subtotal: roomTotal
            });
            
            console.log(`üè® Room: ${roomType.name} - ${roomPrice.toLocaleString()}ƒë √ó ${roomQuantity} √ó ${effectiveNightCount}ƒë√™m = ${roomTotal.toLocaleString()}ƒë`);
          } else {
            console.warn(`‚ö†Ô∏è Room type not found for ID: ${room.roomTypeId}`);
            
            // ‚úÖ Fallback v·ªõi t√™n room type
            roomsBreakdown.push({
              roomTypeId: room.roomTypeId,
              name: `Room Type ${room.roomTypeId}`,
              price: 0,
              quantity: parseInt(room.quantity) || 0,
              nights: effectiveNightCount,
              subtotal: 0
            });
          }
        });
      }

      // ‚úÖ S·ª¨A: Calculate late checkout fee v·ªõi roomTypes
      const lateCheckoutFee = calculateLateCheckoutFee(formData.checkOut, selectedRooms, roomTypes);
      
      // ‚úÖ Calculate services subtotal t·ª´ database
      const servicesSubtotal = calculateServiceTotal(selectedServices || [], availableServices || []);
      
      // ‚úÖ Calculate subtotal INCLUDING late checkout fee (gi·ªëng nh∆∞ booking)
      const subtotal = roomSubtotal + servicesSubtotal + lateCheckoutFee;
      
      // ‚úÖ Calculate promotion discount from subtotal (including late fee)
      const promotionDiscount = calculatePromotionDiscount(subtotal, appliedPromotion);
      const finalTotal = Math.max(0, subtotal - promotionDiscount);
      
      const totalPrice = Math.round(subtotal) || 0;
      const finalTotalRounded = Math.round(finalTotal) || 0;
      
      const breakdown = {
        roomSubtotal: Math.round(roomSubtotal) || 0,
        servicesSubtotal: Math.round(servicesSubtotal) || 0,
        subtotal: Math.round(subtotal) || 0,
        nightCount: effectiveNightCount,
        lateCheckoutFee: Math.round(lateCheckoutFee) || 0,
        totalPrice: totalPrice,
        originalTotal: Math.round(subtotal) || 0,
        promotionDiscount: Math.round(promotionDiscount) || 0,
        finalTotal: finalTotalRounded,
        appliedPromotionInfo: appliedPromotion ? {
          promotionName: appliedPromotion.promotionName,
          discountPercent: appliedPromotion.discountPercent,
          promotionID: appliedPromotion.promotionID
        } : null,
        roomsBreakdown: roomsBreakdown
      };

      setPricingBreakdown(breakdown);
      
      console.log('üí∞ Online booking pricing calculated:', {
        rooms: `${roomSubtotal.toLocaleString()}ƒë`,
        services: `${servicesSubtotal.toLocaleString()}ƒë`,
        lateCheckout: `${lateCheckoutFee.toLocaleString()}ƒë`,
        subtotal: `${subtotal.toLocaleString()}ƒë`,
        promotion: appliedPromotion ? `${appliedPromotion.promotionName} (-${promotionDiscount.toLocaleString()}ƒë)` : 'None',
        totalPrice: `${totalPrice.toLocaleString()}ƒë`,
        final: `${finalTotalRounded.toLocaleString()}ƒë`,
        breakdown: roomsBreakdown
      });
      
    } catch (error) {
      console.error('‚ùå Error calculating online booking pricing:', error);
    }
  }, [
    formData,
    selectedRooms,
    selectedServices,
    availableServices,
    appliedPromotion,
    roomTypes, // ‚úÖ TH√äM roomTypes v√†o dependency
    calculateNights,
    calculateLateCheckoutFee,
    calculateServiceTotal,
    calculatePromotionDiscount
  ]);

  return {
    pricingBreakdown,
    calculateServiceTotal,
    calculateNights,
    calculateLateCheckoutFee,
    calculatePromotionDiscount,
    hasPromotion: !!appliedPromotion,
    promotionSavings: pricingBreakdown.promotionDiscount || 0,
    // ‚úÖ Expose individual functions for external use
    getServicePriceFromDB: (serviceId) => {
      const service = availableServices?.find(s => s.id === serviceId);
      return service?.price || 0;
    }
  };
};